{
  "dataType": "CVE_RECORD",
  "dataVersion": "5.1",
  "cveMetadata": {
    "cveId": "CVE-2024-4435",
    "assignerOrgId": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
    "state": "PUBLISHED",
    "assignerShortName": "Dfinity",
    "dateReserved": "2024-05-02T16:25:27.399Z",
    "datePublished": "2024-05-21T09:41:35.242Z",
    "dateUpdated": "2024-06-04T17:53:57.433Z"
  },
  "containers": {
    "cna": {
      "affected": [
        {
          "collectionURL": "https://crates.io/crates/ic-stable-structures",
          "defaultStatus": "unaffected",
          "packageName": "ic-stable-structures",
          "product": "ic-stable-structures",
          "repo": "https://github.com/dfinity/stable-structures",
          "vendor": "Internet Computer",
          "versions": [
            {
              "lessThan": "0.6.4",
              "status": "affected",
              "version": "0.6.0",
              "versionType": "semver"
            }
          ]
        }
      ],
      "datePublic": "2024-05-21T09:00:00.000Z",
      "descriptions": [
        {
          "lang": "en",
          "supportingMedia": [
            {
              "base64": false,
              "type": "text/html",
              "value": "<p>When storing unbounded types in a <code>BTreeMap</code>, a node is represented as a linked list of \"memory chunks\". It was discovered recently that when we deallocate a node, in some cases only the first memory chunk is deallocated, and the rest of the memory chunks remain (incorrectly) allocated, causing a memory leak. In the worst case, depending on how a canister uses the <code>BTreeMap</code>, an adversary could interact with the canister through its API and trigger interactions with the map that keep consuming memory due to the memory leak. This could potentially lead to using an excessive amount of memory, or even running out of memory.</p><p>This issue has been fixed in <a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/dfinity/stable-structures/pull/212\">#212</a>&nbsp;by changing the logic for deallocating nodes to ensure that all of a node's memory chunks are deallocated <span style=\"background-color: rgb(255, 255, 255);\">and users are asked to upgrade to version </span><code>0.6.4</code><span style=\"background-color: rgb(255, 255, 255);\">.</span>. Tests have been added to prevent regressions of this nature moving forward. <strong>Note:</strong>&nbsp;Users of stable-structure &lt; 0.6.0 are not affected.</p><p><span style=\"background-color: var(--wht);\">Users who are not storing unbounded types in </span><code>BTreeMap</code><span style=\"background-color: var(--wht);\">&nbsp;are not affected and do not need to upgrade. Otherwise, an upgrade to version </span><code>0.6.4</code><span style=\"background-color: var(--wht);\">&nbsp;is necessary.</span></p>"
            }
          ],
          "value": "When storing unbounded types in a BTreeMap, a node is represented as a linked list of \"memory chunks\". It was discovered recently that when we deallocate a node, in some cases only the first memory chunk is deallocated, and the rest of the memory chunks remain (incorrectly) allocated, causing a memory leak. In the worst case, depending on how a canister uses the BTreeMap, an adversary could interact with the canister through its API and trigger interactions with the map that keep consuming memory due to the memory leak. This could potentially lead to using an excessive amount of memory, or even running out of memory.\n\nThis issue has been fixed in  #212 https://github.com/dfinity/stable-structures/pull/212 \u00a0by changing the logic for deallocating nodes to ensure that all of a node's memory chunks are deallocated and users are asked to upgrade to version 0.6.4.. Tests have been added to prevent regressions of this nature moving forward. Note:\u00a0Users of stable-structure < 0.6.0 are not affected.\n\nUsers who are not storing unbounded types in BTreeMap\u00a0are not affected and do not need to upgrade. Otherwise, an upgrade to version 0.6.4\u00a0is necessary."
        }
      ],
      "impacts": [
        {
          "capecId": "CAPEC-131",
          "descriptions": [
            {
              "lang": "en",
              "value": "CAPEC-131: Resource Leak Exposure"
            }
          ]
        }
      ],
      "metrics": [
        {
          "cvssV3_1": {
            "attackComplexity": "HIGH",
            "attackVector": "NETWORK",
            "availabilityImpact": "HIGH",
            "baseScore": 5.9,
            "baseSeverity": "MEDIUM",
            "confidentialityImpact": "NONE",
            "integrityImpact": "NONE",
            "privilegesRequired": "NONE",
            "scope": "UNCHANGED",
            "userInteraction": "NONE",
            "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "version": "3.1"
          },
          "format": "CVSS",
          "scenarios": [
            {
              "lang": "en",
              "value": "GENERAL"
            }
          ]
        }
      ],
      "problemTypes": [
        {
          "descriptions": [
            {
              "cweId": "CWE-401",
              "description": "CWE-401 Missing Release of Memory after Effective Lifetime",
              "lang": "en",
              "type": "CWE"
            }
          ]
        }
      ],
      "providerMetadata": {
        "orgId": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
        "shortName": "Dfinity",
        "dateUpdated": "2024-05-21T09:41:35.242Z"
      },
      "references": [
        {
          "url": "https://github.com/dfinity/stable-structures/pull/212"
        },
        {
          "url": "https://docs.rs/ic-stable-structures/0.6.4/ic_stable_structures/"
        },
        {
          "url": "https://internetcomputer.org/docs/current/developer-docs/smart-contracts/maintain/storage#stable-memory"
        }
      ],
      "source": {
        "discovery": "UNKNOWN"
      },
      "title": "BTreeMap memory leak when deallocating nodes with overflows",
      "x_generator": {
        "engine": "Vulnogram 0.2.0"
      }
    },
    "adp": [
      {
        "metrics": [
          {
            "other": {
              "type": "ssvc",
              "content": {
                "id": "CVE-2024-4435",
                "role": "CISA Coordinator",
                "options": [
                  {
                    "Exploitation": "none"
                  },
                  {
                    "Automatable": "no"
                  },
                  {
                    "Technical Impact": "partial"
                  }
                ],
                "version": "2.0.3",
                "timestamp": "2024-05-23T20:17:52.489055Z"
              }
            }
          }
        ],
        "providerMetadata": {
          "orgId": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
          "shortName": "CISA-ADP",
          "dateUpdated": "2024-05-23T20:17:57.345Z"
        },
        "title": "CISA ADP Vulnrichment"
      }
    ]
  }
}