{
  "dataType": "CVE_RECORD",
  "containers": {
    "adp": [
      {
        "title": "CISA ADP Vulnrichment",
        "metrics": [
          {
            "other": {
              "type": "ssvc",
              "content": {
                "id": "CVE-2024-27397",
                "role": "CISA Coordinator",
                "options": [
                  {
                    "Exploitation": "none"
                  },
                  {
                    "Automatable": "no"
                  },
                  {
                    "Technical Impact": "partial"
                  }
                ],
                "version": "2.0.3",
                "timestamp": "2024-06-17T17:39:42.529200Z"
              }
            }
          }
        ],
        "providerMetadata": {
          "orgId": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
          "shortName": "CISA-ADP",
          "dateUpdated": "2024-06-17T17:39:43.539Z"
        }
      }
    ],
    "cna": {
      "title": "netfilter: nf_tables: use timestamp to check for set element timeout",
      "affected": [
        {
          "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
          "vendor": "Linux",
          "product": "Linux",
          "versions": [
            {
              "status": "affected",
              "version": "c3e1b005ed1c",
              "lessThan": "383182db8d58",
              "versionType": "git"
            },
            {
              "status": "affected",
              "version": "c3e1b005ed1c",
              "lessThan": "7395dfacfff6",
              "versionType": "git"
            }
          ],
          "programFiles": [
            "include/net/netfilter/nf_tables.h",
            "net/netfilter/nf_tables_api.c",
            "net/netfilter/nft_set_hash.c",
            "net/netfilter/nft_set_pipapo.c",
            "net/netfilter/nft_set_rbtree.c"
          ],
          "defaultStatus": "unaffected"
        },
        {
          "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
          "vendor": "Linux",
          "product": "Linux",
          "versions": [
            {
              "status": "affected",
              "version": "4.1"
            },
            {
              "status": "unaffected",
              "version": "0",
              "lessThan": "4.1",
              "versionType": "custom"
            },
            {
              "status": "unaffected",
              "version": "6.7.5",
              "versionType": "custom",
              "lessThanOrEqual": "6.7.*"
            },
            {
              "status": "unaffected",
              "version": "6.8",
              "versionType": "original_commit_for_fix",
              "lessThanOrEqual": "*"
            }
          ],
          "programFiles": [
            "include/net/netfilter/nf_tables.h",
            "net/netfilter/nf_tables_api.c",
            "net/netfilter/nft_set_hash.c",
            "net/netfilter/nft_set_pipapo.c",
            "net/netfilter/nft_set_rbtree.c"
          ],
          "defaultStatus": "affected"
        }
      ],
      "references": [
        {
          "url": "https://git.kernel.org/stable/c/383182db8d58c4237772ba0764cded4938a235c3"
        },
        {
          "url": "https://git.kernel.org/stable/c/7395dfacfff65e9938ac0889dafa1ab01e987d15"
        }
      ],
      "x_generator": {
        "engine": "bippy-a5840b7849dd"
      },
      "descriptions": [
        {
          "lang": "en",
          "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: use timestamp to check for set element timeout\n\nAdd a timestamp field at the beginning of the transaction, store it\nin the nftables per-netns area.\n\nUpdate set backend .insert, .deactivate and sync gc path to use the\ntimestamp, this avoids that an element expires while control plane\ntransaction is still unfinished.\n\n.lookup and .update, which are used from packet path, still use the\ncurrent time to check if the element has expired. And .get path and dump\nalso since this runs lockless under rcu read size lock. Then, there is\nasync gc which also needs to check the current time since it runs\nasynchronously from a workqueue."
        }
      ],
      "providerMetadata": {
        "orgId": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "shortName": "Linux",
        "dateUpdated": "2024-05-29T05:28:23.730Z"
      }
    }
  },
  "cveMetadata": {
    "cveId": "CVE-2024-27397",
    "state": "PUBLISHED",
    "dateUpdated": "2024-06-17T17:44:15.867Z",
    "dateReserved": "2024-02-25T13:47:42.677Z",
    "assignerOrgId": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
    "datePublished": "2024-05-09T16:37:22.463Z",
    "assignerShortName": "Linux"
  },
  "dataVersion": "5.1"
}