{
  "dataType": "CVE_RECORD",
  "containers": {
    "cna": {
      "title": "scsi: core: sysfs: Fix hang when device state is set via sysfs",
      "affected": [
        {
          "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
          "vendor": "Linux",
          "product": "Linux",
          "versions": [
            {
              "status": "affected",
              "version": "69aa1a1a569f",
              "lessThan": "edd783162bf2",
              "versionType": "git"
            },
            {
              "status": "affected",
              "version": "711459514e29",
              "lessThan": "a792e0128d23",
              "versionType": "git"
            },
            {
              "status": "affected",
              "version": "f0f82e2476f6",
              "lessThan": "bcc0e3175a97",
              "versionType": "git"
            },
            {
              "status": "affected",
              "version": "f0f82e2476f6",
              "lessThan": "4edd8cd4e86d",
              "versionType": "git"
            }
          ],
          "programFiles": [
            "drivers/scsi/scsi_sysfs.c"
          ],
          "defaultStatus": "unaffected"
        },
        {
          "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
          "vendor": "Linux",
          "product": "Linux",
          "versions": [
            {
              "status": "affected",
              "version": "5.14"
            },
            {
              "status": "unaffected",
              "version": "0",
              "lessThan": "5.14",
              "versionType": "custom"
            },
            {
              "status": "unaffected",
              "version": "5.4.162",
              "versionType": "custom",
              "lessThanOrEqual": "5.4.*"
            },
            {
              "status": "unaffected",
              "version": "5.10.82",
              "versionType": "custom",
              "lessThanOrEqual": "5.10.*"
            },
            {
              "status": "unaffected",
              "version": "5.15.5",
              "versionType": "custom",
              "lessThanOrEqual": "5.15.*"
            },
            {
              "status": "unaffected",
              "version": "5.16",
              "versionType": "original_commit_for_fix",
              "lessThanOrEqual": "*"
            }
          ],
          "programFiles": [
            "drivers/scsi/scsi_sysfs.c"
          ],
          "defaultStatus": "affected"
        }
      ],
      "references": [
        {
          "url": "https://git.kernel.org/stable/c/edd783162bf2385b43de6764f2d4c6e9f4f6be27"
        },
        {
          "url": "https://git.kernel.org/stable/c/a792e0128d232251edb5fdf42fb0f9fbb0b44a73"
        },
        {
          "url": "https://git.kernel.org/stable/c/bcc0e3175a976b7fa9a353960808adb0bb49ead8"
        },
        {
          "url": "https://git.kernel.org/stable/c/4edd8cd4e86dd3047e5294bbefcc0a08f66a430f"
        }
      ],
      "x_generator": {
        "engine": "bippy-a5840b7849dd"
      },
      "descriptions": [
        {
          "lang": "en",
          "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: sysfs: Fix hang when device state is set via sysfs\n\nThis fixes a regression added with:\n\ncommit f0f82e2476f6 (\"scsi: core: Fix capacity set to zero after\nofflinining device\")\n\nThe problem is that after iSCSI recovery, iscsid will call into the kernel\nto set the dev's state to running, and with that patch we now call\nscsi_rescan_device() with the state_mutex held. If the SCSI error handler\nthread is just starting to test the device in scsi_send_eh_cmnd() then it's\ngoing to try to grab the state_mutex.\n\nWe are then stuck, because when scsi_rescan_device() tries to send its I/O\nscsi_queue_rq() calls -> scsi_host_queue_ready() -> scsi_host_in_recovery()\nwhich will return true (the host state is still in recovery) and I/O will\njust be requeued. scsi_send_eh_cmnd() will then never be able to grab the\nstate_mutex to finish error handling.\n\nTo prevent the deadlock move the rescan-related code to after we drop the\nstate_mutex.\n\nThis also adds a check for if we are already in the running state. This\nprevents extra scans and helps the iscsid case where if the transport class\nhas already onlined the device during its recovery process then we don't\nneed userspace to do it again plus possibly block that daemon."
        }
      ],
      "providerMetadata": {
        "orgId": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "shortName": "Linux",
        "dateUpdated": "2024-05-28T19:39:41.505Z"
      }
    },
    "adp": [
      {
        "metrics": [
          {
            "other": {
              "type": "ssvc",
              "content": {
                "id": "CVE-2021-47192",
                "role": "CISA Coordinator",
                "options": [
                  {
                    "Exploitation": "none"
                  },
                  {
                    "Automatable": "no"
                  },
                  {
                    "Technical Impact": "partial"
                  }
                ],
                "version": "2.0.3",
                "timestamp": "2024-04-10T19:44:37.430694Z"
              }
            }
          }
        ],
        "providerMetadata": {
          "shortName": "CISAADP",
          "orgId": "8c464350-323a-4346-a867-fc54517fa145",
          "dateUpdated": "2024-05-23T19:01:23.094Z"
        }
      }
    ]
  },
  "cveMetadata": {
    "cveId": "CVE-2021-47192",
    "state": "PUBLISHED",
    "dateUpdated": "2024-05-28T19:39:41.505Z",
    "dateReserved": "2024-03-25T09:12:14.113Z",
    "assignerOrgId": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
    "datePublished": "2024-04-10T18:56:30.097Z",
    "assignerShortName": "Linux"
  },
  "dataVersion": "5.1"
}